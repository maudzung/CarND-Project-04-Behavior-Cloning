import random

import cv2
import numpy as np
from scipy.ndimage import rotate


class Compose(object):
    def __init__(self, transforms, p=1.0):
        self.transforms = transforms
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            for t in self.transforms:
                img, label = t(img, angle)
        return img, angle


class Crop(object):
    def __init__(self, top_percent, bottom_percent, p=0.5):
        self.top_percent = top_percent
        self.bottom_percent = bottom_percent
        assert 0 <= self.top_percent < 0.5, 'top_percent should be between 0.0 and 0.5'
        assert 0 <= self.bottom_percent < 0.5, 'top_percent should be between 0.0 and 0.5'
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            height = img.shape[0]
            top = int(np.ceil(height * self.top_percent))
            bottom = height - int(np.ceil(height * self.bottom_percent))

            img = img[top:bottom, :]
        return img, angle


class Resize(object):
    def __init__(self, new_size, p=0.5):
        self.new_size = new_size
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            img = cv2.resize(img, self.new_size)

        return img, angle


class Random_HFlip(object):
    def __init__(self, p=0.5):
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            img = np.fliplr(img)
            angle *= -1

        return img, angle


class Random_Gamma(object):
    """
        Random gamma correction is used as an alternative method changing the brightness of
        training images.
        http://www.pyimagesearch.com/2015/10/05/opencv-gamma-correction/
        :param image:
            Source image
        :return:
            New image generated by applying gamma correction to the source image
        """

    def __init__(self, p=0.5):
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            gamma = np.random.uniform(0.4, 1.5)
            inv_gamma = 1.0 / gamma
            table = np.array([((i / 255.0) ** inv_gamma) * 255
                              for i in np.arange(0, 256)]).astype("uint8")

            # apply gamma correction using the lookup table
            img = cv2.LUT(img, table)

        return img, angle


class Random_Shear(object):
    """
    Source: https://medium.com/@ksakmann/behavioral-cloning-make-a-car-drive-like-yourself-dc6021152713#.7k8vfppvk
    :param image:
        Source image on which the shear operation will be applied
    :param steering_angle:
        The steering angle of the image
    :param shear_range:
        Random shear between [-shear_range, shear_range + 1] will be applied
    :return:
        The image generated by applying random shear on the source image
    """

    def __init__(self, shear_range=20, p=0.5):
        self.shear_range = shear_range
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            h, w, ch = img.shape
            dx = np.random.randint(-self.shear_range, self.shear_range + 1)
            random_point = [w / 2 + dx, h / 2]
            pts1 = np.float32([[0, h], [w, h], [w / 2, h / 2]])
            pts2 = np.float32([[0, h], [w, h], random_point])
            dsteering = dx / (h / 2) * 360 / (2 * np.pi * 25.0) / 6.0
            M = cv2.getAffineTransform(pts1, pts2)

            img = cv2.warpAffine(img, M, (w, h), borderMode=1)
            angle += dsteering

        return img, angle


class Random_Rotate(object):
    def __init__(self, rotation_angle_limit=15, p=0.5):
        self.rotation_angle_limit = rotation_angle_limit
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            random_angle = np.random.uniform(-self.rotation_angle_limit, self.rotation_angle_limit + 1)
            rad = (np.pi / 180.0) * random_angle
            img = rotate(img, random_angle, reshape=False)
            angle += (-1) * rad

        return img, angle
