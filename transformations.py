import random

import cv2
import numpy as np
from scipy.ndimage import rotate


class Compose(object):
    def __init__(self, transforms, p=1.0):
        self.transforms = transforms
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            for t in self.transforms:
                img, label = t(img, angle)
        return img, angle


class Crop(object):
    def __init__(self, top, bottom, p=0.5):
        self.top = top
        self.bottom = bottom
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            img = img[self.top:self.bottom, :, :]
        return img, angle


class Resize(object):
    def __init__(self, new_size, p=0.5):
        self.new_size = new_size
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            img = cv2.resize(img, self.new_size)

        return img, angle


class Convert_RGB2YUV(object):
    def __init__(self, p=0.5):
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            img = cv2.cvtColor(img, cv2.COLOR_RGB2YUV)

        return img, angle


class Random_HFlip(object):
    def __init__(self, p=0.5):
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            img = cv2.flip(img, 1)
            angle *= -1

        return img, angle


class Random_Brightness(object):
    def __init__(self, p=0.5):
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
            ratio = 1.0 + (np.random.rand() - 0.5)
            hsv[:, :, 2] = hsv[:, :, 2] * ratio
            img = cv2.cvtColor(hsv, cv2.COLOR_HSV2RGB)

        return img, angle


class Random_Gamma(object):
    """
        Random gamma correction is used as an alternative method changing the brightness of
        training images.
        http://www.pyimagesearch.com/2015/10/05/opencv-gamma-correction/
        :param image:
            Source image
        :return:
            New image generated by applying gamma correction to the source image
        """

    def __init__(self, p=0.5):
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            gamma = np.random.uniform(0.4, 1.5)
            inv_gamma = 1.0 / gamma
            table = np.array([((i / 255.0) ** inv_gamma) * 255
                              for i in np.arange(0, 256)]).astype("uint8")

            # apply gamma correction using the lookup table
            img = cv2.LUT(img, table)

        return img, angle


class Random_Shear(object):
    """
    Source: https://medium.com/@ksakmann/behavioral-cloning-make-a-car-drive-like-yourself-dc6021152713#.7k8vfppvk
    :param image:
        Source image on which the shear operation will be applied
    :param steering_angle:
        The steering angle of the image
    :param shear_range:
        Random shear between [-shear_range, shear_range + 1] will be applied
    :return:
        The image generated by applying random shear on the source image
    """

    def __init__(self, shear_range=20, p=0.5):
        self.shear_range = shear_range
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            h, w, ch = img.shape
            dx = np.random.randint(-self.shear_range, self.shear_range + 1)
            random_point = [w / 2 + dx, h / 2]
            pts1 = np.float32([[0, h], [w, h], [w / 2, h / 2]])
            pts2 = np.float32([[0, h], [w, h], random_point])
            dsteering = dx / (h / 2) * 360 / (2 * np.pi * 25.0) / 6.0
            M = cv2.getAffineTransform(pts1, pts2)

            img = cv2.warpAffine(img, M, (w, h), borderMode=1)
            angle += dsteering

        return img, angle


class Random_Rotate(object):
    def __init__(self, rotation_angle_limit=15, p=0.5):
        self.rotation_angle_limit = rotation_angle_limit
        self.p = p

    def __call__(self, img, angle):
        if random.random() <= self.p:
            random_angle = np.random.uniform(-self.rotation_angle_limit, self.rotation_angle_limit + 1)
            rad = (np.pi / 180.0) * random_angle
            img = rotate(img, random_angle, reshape=False)
            angle += (-1) * rad

        return img, angle
